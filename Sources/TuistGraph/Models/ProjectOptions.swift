import Foundation

extension Project {
    /// Additional options related to the `Project`
    public struct Options: Codable, Hashable {
        /// Defines how to generate automatic schemes
        public let automaticSchemesOptions: AutomaticSchemesOptions

        /// Disables generating Bundle accessors.
        public let disableBundleAccessors: Bool

        /// Disable the synthesized resource accessors generation
        public let disableSynthesizedResourceAccessors: Bool

        /// Text settings to override user ones for current project
        public let textSettings: TextSettings

        public init(
            automaticSchemesOptions: AutomaticSchemesOptions,
            disableBundleAccessors: Bool,
            disableSynthesizedResourceAccessors: Bool,
            textSettings: TextSettings
        ) {
            self.automaticSchemesOptions = automaticSchemesOptions
            self.disableBundleAccessors = disableBundleAccessors
            self.disableSynthesizedResourceAccessors = disableSynthesizedResourceAccessors
            self.textSettings = textSettings
        }
    }
}

// MARK: - AutomaticSchemesOptions

extension Project.Options {
    /// The automatic schemes options
    public enum AutomaticSchemesOptions: Codable, Hashable {
        /// Defines how to group targets into scheme for autogenerated schemes
        public enum TargetSchemesGrouping: Codable, Hashable {
            /// Generate a single scheme per project
            case singleScheme

            /// Group the targets according to their name suffixes
            case byNameSuffix(build: Set<String>, test: Set<String>, run: Set<String>)

            /// Do not group targets, create a scheme for each target
            case notGrouped
        }

        /// Enable autogenerated schemes
        case enabled(
            targetSchemesGrouping: TargetSchemesGrouping,
            codeCoverageEnabled: Bool,
            testingOptions: TestingOptions
        )

        /// Disable autogenerated schemes
        case disabled
    }

    /// The text settings options
    public struct TextSettings: Codable, Hashable {
        /// Whether tabs should be used instead of spaces
        public let usesTabs: Bool?

        /// The width of space indent
        public let indentWidth: UInt?

        /// The width of tab indent
        public let tabWidth: UInt?

        /// Whether lines should be wrapped or not
        public let wrapsLines: Bool?

        public init(
            usesTabs: Bool?,
            indentWidth: UInt?,
            tabWidth: UInt?,
            wrapsLines: Bool?
        ) {
            self.usesTabs = usesTabs
            self.indentWidth = indentWidth
            self.tabWidth = tabWidth
            self.wrapsLines = wrapsLines
        }
    }
}

// MARK: - Array + ProjectOption

extension Project.Options {
    public var targetSchemesGrouping: AutomaticSchemesOptions.TargetSchemesGrouping? {
        switch automaticSchemesOptions {
        case let .enabled(targetSchemesGrouping, _, _):
            return targetSchemesGrouping
        case .disabled:
            return nil
        }
    }

    public var codeCoverageEnabled: Bool {
        switch automaticSchemesOptions {
        case let .enabled(_, codeCoverageEnabled, _):
            return codeCoverageEnabled
        case .disabled:
            return false
        }
    }

    public var testingOptions: TestingOptions {
        switch automaticSchemesOptions {
        case let .enabled(_, _, testingOptions):
            return testingOptions
        case .disabled:
            return []
        }
    }
}

// Make TargetSchemesGrouping encoding predictable for testing

extension Project.Options.AutomaticSchemesOptions.TargetSchemesGrouping {
    private enum Kind: Codable {
        case singleScheme
        case byNameSuffix
        case notGrouped
    }

    private enum CodingKeys: String, CodingKey {
        case kind
        case build
        case test
        case run
    }


    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let kind = try container.decode(Kind.self, forKey: .kind)
        switch kind {
        case .singleScheme:
            self = .singleScheme
        case .byNameSuffix:
            let build = try container.decode(Set<String>.self, forKey: .build)
            let test = try container.decode(Set<String>.self, forKey: .test)
            let run = try container.decode(Set<String>.self, forKey: .run)
            self = .byNameSuffix(build: build, test: test, run: run)
        case .notGrouped:
            self = .notGrouped
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .singleScheme:
            try container.encode(Kind.singleScheme, forKey: .kind)
        case let .byNameSuffix(build, test, run):
            try container.encode(Kind.byNameSuffix, forKey: .kind)
            try container.encode(build.sorted(), forKey: .build)
            try container.encode(test.sorted(), forKey: .test)
            try container.encode(run.sorted(), forKey: .run)
        case .notGrouped:
            try container.encode(Kind.notGrouped, forKey: .kind)
        }
    }
}
